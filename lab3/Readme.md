# 实验三

## 实验题目：利用MPI解决N体问题

> 实验环境：
>
> 操作系统：Windows 10家庭中文版
>
> 编译器：gcc 8.1.0
>
> IDE：Visual Studio Community 2019 16.4.5
>
> CPU：Intel i5-7300HQ 2.50GHz (4核)
>
> 内存：8.00GB

### 算法设计与分析

利用MPI求解N体问题的思路如下：

首先把对小球运动的计算均匀分配给每个进程。当一个进程计算一个小球该周期的运动情况时，先利用compute force函数，根据万有引力定律计算出其他小球对它的合力矢量，然后调用compute velocities函数，由之前计算出的受力除以小球质量得到该小球这个周期的速度矢量；最后在compute positions函数中用上个周期的位置矢量加上该周期的速度矢量得到这个周期结束时小球的位置矢量，结束一个周期的模拟。

当一个周期模拟结束时，还需要设置同步，所有进程都完成本周期模拟时才能开始下一周期的模拟。

具体实现中，仿真的一个周期为1秒，最后输出的结果中坐标的单位是cm，速度单位是cm/s，力的单位为N

### 核心代码

计算受力的代码如下:

```c++
void compute_force(int id,ld x[],ld y[],ld fx[],ld fy[]) {//计算id号小球受力
    //ld = long double
    ld sum_fx = 0, sum_fy = 0;//合力的两个分量
    for (int i = 0; i < n; i++) {
        if (i == id) continue;
        ld r2 = (x[id] - x[i]) * (x[id] - x[i]) + (y[id] - y[i]) * (y[id] - y[i]);//距离平方
        ld r = sqrtl(r2);
        ld f = G * Mass * Mass / r2;//受力
        ld dir_x = (x[i] - x[id]) / r;//受力在x的分量
        ld dir_y = (y[i] - y[id]) / r;//受力在y的分量
        sum_fx += f * dir_x;//计算合力的分量
        sum_fy += f * dir_y;
    }
    fx[id] = sum_fx, fy[id] = sum_fy;
}
```

计算速度的代码如下:

```c++
void compute_velocities(int id,ld vx[], ld vy[], ld fx[], ld fy[]) {//计算速度
    vx[id] += fx[id] / Mass;
    vy[id] += fy[id] / Mass;
}
```

计算坐标的函数如下:

```c++
void compute_positions(int id, ld x[], ld y[], ld vx[], ld vy[]) {//计算坐标
    x[id] += vx[id];
    y[id] += vy[id];
}
```

每个周期对每个小球依次调用这三个函数即可。

### 实验结果

小球个数为36，仿真周期为100（即100s）时结果如下图：六个参数依次为小球的x、y坐标；小球在x、y方向的速度分量；小球在x、y方向的受力分量。

<img src="E:\STUDY\Parallel Computing\lab3\1.jpg" style="zoom:67%;" />

下表中规模用小球个数n/仿真周期tim的格式展示，运行时间的单位是秒。由于实验环境的CPU物理核心数为4，8个进程没有优化的效果，所以没有展示在下表中。

​																						运行时间

| 规模/进程数                     | 1         | 2        | 4        |
| ------------------------------- | --------- | -------- | -------- |
| 64（小球个数）/2000（仿真周期） | 0.315314  | 0.167448 | 0.112746 |
| 64/10000                        | 1.601419  | 0.832246 | 0.538921 |
| 256/2000                        | 5.058035  | 2.502916 | 1.351707 |
| 256/5000                        | 12.531744 | 6.234290 | 3.385818 |

​																						加速比

| 规模/进程数 | 1    | 2     | 4     |
| ----------- | ---- | ----- | ----- |
| 64/2000     | 1    | 1.883 | 2.797 |
| 64/10000    | 1    | 1.924 | 2.972 |
| 256/2000    | 1    | 2.021 | 3.742 |
| 256/5000    | 1    | 2.010 | 3.701 |

### 分析与总结

从上面的结果可以看出，多线程并行模拟能有效达到加速程序运行的效果。在问题规模较小的时候加速比离进程数还有一定差距，这是因为创建线程的用时以及通信时间还不能被忽略。随着问题规模的增大，计算用时将占用绝大部分运行时间，加速比也将逐渐趋于进程数量。